# --- Day 21: Fractal Art ---
#
# You find a program trying to generate some art.  It uses a strange
# process that involves repeatedly enhancing the detail of an image
# through a set of rules.
#
# The image consists of a two-dimensional square grid of pixels that
# are either on (#) or off (.).  The program always begins with this
# pattern:
#
# .#.
# ..#
# ###
#
# Because the pattern is both 3 pixels wide and 3 pixels tall, it is
# said to have a size of 3.
#
# Then, the program repeats the following process:
#
#   - If the size is evenly divisible by 2, break the pixels up into
#     2x2 squares, and convert each 2x2 square into a 3x3 square by
#     following the corresponding enhancement rule.
#   - Otherwise, the size is evenly divisible by 3; break the pixels
#     up into 3x3 squares, and convert each 3x3 square into a 4x4
#     square by following the corresponding enhancement rule.
#   - Because each square of pixels is replaced by a larger one, the
#     image gains pixels and so its size increases.
#
# The artist's book of enhancement rules is nearby (your puzzle
# input); however, it seems to be missing rules.  The artist explains
# that sometimes, one must rotate or flip the input pattern to find a
# match.  (Never rotate or flip the output pattern, though.)  Each
# pattern is written concisely: rows are listed as single units,
# ordered top-down, and separated by slashes.  For example, the
# following rules correspond to the adjacent patterns:
#
# ../.#  =  ..
#           .#
#
#                 .#.
# .#./..#/###  =  ..#
#                 ###
#
#                         #..#
# #..#/..../#..#/.##.  =  ....
#                         #..#
#                         .##.
#
# When searching for a rule to use, rotate and flip the pattern as
# necessary.  For example, all of the following patterns match the
# same rule:
#
# .#.   .#.   #..   ###
# ..#   #..   #.#   ..#
# ###   ###   ##.   .#.
#
# How many pixels stay on after 5 iterations?
#
# --------------------
#
# Pattern symmetries are described by the dihedral group D_4, whose 8
# members can be generated by successively rotating a pattern 90
# degrees, optionally flipping the pattern afterward each time.  To
# rotate a pattern clockwise we transpose it and then reverse the
# columns.

def to_grid(spec)
  spec.split("/").map {|r| r.chars }
end

def symmetries(pattern)
  Enumerator.new do |y|
    4.times do
      pattern = pattern.transpose
      pattern.each {|r| r.reverse! }
      y << pattern
      y << pattern.reverse
    end
  end
end

Rules = {}
IO.foreach("21.in") do |l|
  m = /^([.#]{2}\/[.#]{2}) => ((?:[.#]{3}\/){2}[.#]{3})$/.match(l)
  if m
    symmetries(to_grid(m[1])).each {|p| Rules[p] = to_grid(m[2]) }
  else
    m = /^((?:[.#]{3}\/){2}[.#]{3}) => ((?:[.#]{4}\/){3}[.#]{4})$/.match(l)
    symmetries(to_grid(m[1])).each {|p| Rules[p] = to_grid(m[2]) }
  end
end

def solve(iterations)
  grid = to_grid(".#./..#/###")
  iterations.times do
    n = (grid.length%2 == 0? 2 : 3)
    new_grid = []
    (0...grid.length).step(n).each do |rr|
      (n+1).times { new_grid.push([]) }
      (0...grid.length).step(n).each do |cc|
        p = grid[rr,n].map {|r| r[cc,n] }
        r = Rules[p]
        (0..n).each {|k| new_grid[k-n-1].concat(r[k]) }
      end
    end
    grid = new_grid
  end
  grid.join.count("#")
end

puts solve(5)

# --- Part Two ---
#
# How many pixels stay on after 18 iterations?

puts solve(18)
